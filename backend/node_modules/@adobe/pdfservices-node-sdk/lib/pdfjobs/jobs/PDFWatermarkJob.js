"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFWatermarkJob = void 0;
const PDFServicesJob_1 = require("./PDFServicesJob");
const ValidationUtil_1 = require("../../internal/util/ValidationUtil");
const CloudAsset_1 = require("../../io/CloudAsset");
const PDFWatermarkInternalAssetRequest_1 = require("../../internal/dto/request/pdfwatermark/PDFWatermarkInternalAssetRequest");
const PDFWatermarkExternalAssetRequest_1 = require("../../internal/dto/request/pdfwatermark/PDFWatermarkExternalAssetRequest");
const DefaultRequestHeaders_1 = require("../../internal/http/DefaultRequestHeaders");
const PDFServicesHelper_1 = require("../../internal/PDFServicesHelper");
const OperationHeaderInfoEndpointMap_1 = require("../../internal/constants/OperationHeaderInfoEndpointMap");
const uuid_1 = require("uuid");
/**
 * A job that add a watermark on specified pages of PDF document using a source watermark PDF. The first page of source
 * watermark PDF will be added as a watermark in input PDF document.
 *
 * @example
 * Sample Usage:
 * ```js
 *         const sourceFileReadStream = fs.createReadStream("<SOURCE_PATH>");
 *         const waterMarkFileReadStream = fs.createReadStream("<WATERMARK_SOURCE_PATH>");
 *
 *         const credentials = new ServicePrincipalCredentials({
 *             clientId: process.env.PDF_SERVICES_CLIENT_ID,
 *             clientSecret: process.env.PDF_SERVICES_CLIENT_SECRET
 *         });
 *
 *         const pdfServices = new PDFServices({credentials});
 *
 *         const [inputAsset, watermarkAsset] = await pdfServices.uploadAssets({
 *             streamAssets: [{
 *                 readStream: sourceFileReadStream,
 *                 mimeType: MimeType.PDF
 *             }, {
 *                 readStream: waterMarkFileReadStream,
 *                 mimeType: MimeType.PDF
 *             }]
 *         });
 *
 *         const pageRangesForWatermark = new PageRanges().addSinglePage(1);
 *
 *         const watermarkAppearance = new WatermarkAppearance({
 *             appearOnForeground: false,
 *             opacity: 50,
 *         });
 *
 *         const pdfWatermarkParams = new PDFWatermarkParams({
 *             watermarkAppearance: watermarkAppearance,
 *             pageRanges: pageRangesForWatermark
 *         })
 *
 *         const job = new PDFWatermarkJob({
 *             inputAsset: inputAsset,
 *             watermarkAsset: watermarkAsset,
 *             params: pdfWatermarkParams
 *         });
 *
 *         const pollingURL = await pdfServices.submit({job});
 *
 *         const pdfServicesResponse = await pdfServices.getJobResult({
 *             pollingURL,
 *             resultType: PDFWatermarkResult
 *         });
 *
 *         const resultAsset = pdfServicesResponse.result.asset;
 *         const streamAsset = await pdfServices.getContent({asset: resultAsset});
 * ```
 */
class PDFWatermarkJob extends PDFServicesJob_1.PDFServicesJob {
    /**
     * Constructs a new `PDFWatermarkJob` instance.
     *
     * @param params The parameters for constructing an instance of `PDFWatermarkJob`.
     * @param params.inputAsset The input asset of PDF document on which watermark has to be applied.
     * Cannot be undefined.
     * @param params.watermarkAsset The input asset of PDF document whose first page will be used as watermark.
     * Cannot be undefined.
     * @param [params.params] {@link PDFWatermarkParams} object containing the parameters for PDF watermark.
     * @param [params.outputAsset] {@link Asset} object representing the output asset.
     * @remarks External assets can be set as output only when input is external asset as well.
     */
    constructor(params) {
        super();
        ValidationUtil_1.ValidationUtil.validateWatermarkJobParams(params);
        this._inputAsset = params.inputAsset;
        this._watermarkAsset = params.watermarkAsset;
        this._params = params.params;
        this._outputAsset = params.outputAsset;
    }
    /**
     * @hidden
     */
    async process(executionContext, notifierConfigList) {
        this.validate(executionContext);
        const watermarkPDFRequest = this.generatePDFServicesAPIRequest(notifierConfigList), xRequestId = (0, uuid_1.v4)(), response = await PDFServicesHelper_1.PDFServicesHelper.submitJob(executionContext, watermarkPDFRequest, xRequestId, OperationHeaderInfoEndpointMap_1.OperationHeaderInfoEndpointMap.PDF_WATERMARK);
        return response.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.LOCATION_HEADER_NAME];
    }
    generatePDFServicesAPIRequest(notifierConfigList) {
        let watermarkPDFRequest;
        if (this._inputAsset instanceof CloudAsset_1.CloudAsset) {
            watermarkPDFRequest = new PDFWatermarkInternalAssetRequest_1.PDFWatermarkInternalAssetRequest(this._inputAsset.assetId, this._watermarkAsset.assetId, this._params, notifierConfigList);
        }
        else {
            watermarkPDFRequest = new PDFWatermarkExternalAssetRequest_1.PDFWatermarkExternalAssetRequest(this._inputAsset, this._watermarkAsset, this._params, this._outputAsset, notifierConfigList);
        }
        return watermarkPDFRequest;
    }
}
exports.PDFWatermarkJob = PDFWatermarkJob;
//# sourceMappingURL=PDFWatermarkJob.js.map